#### Team-Seeschwalbe - Totuosity

#### Daten einlesen und bearbeiten ####
setwd("~/Uni/Lernstoff/Master/3. Semester/04 Statistical Consulting/Daten")
dat <- read.csv("slick2-h1-h2.csv")

## Paket laden
library(moveHMM)
## Daten anzeigen
View(dat)
head(dat)

## Anzahl der Beobachtungen pro Tern
table(dat$ID)

## neue Spalte im Datensatz erstellen mit der Frequency
data2 <- dat$ID
x <- data.frame(data2, freq=ave(seq_along(data2), data2, FUN=length))
dat$freq <- x$freq

which(data_frame$Freq >400) #welche Terns haben mehr als 400 Beobachtungen
sum(data_frame$Freq >400) #wie viele Terns haben mehr als 400 Beobachtungen

## Datensatz nur mit Terns, die >400 bzw. >700 Beobachtungspunkte besitzen
#dat_400 <- subset(dat, dat$freq > 400)
dat_700 <- subset(dat, dat$freq > 700)

## Daten aufbereiten
data <- prepData(dat_700, type="UTM")

#### log(tortuosity) dem Datensatz beifügen ####

## neue Spalte im Datensatz mit log von tortuosity
data$log.tort <- log(data$tortuosity)
#View(data)

#### fitting 2-States HMM with tortuosity####

mllk.tort <- function(theta.star, x, N){
  Gamma <- diag(N) #identity matrix 
  Gamma[!Gamma] <- exp(theta.star[1:2]) #turn zeros in matrix (off-diagonal entries) into exponentials of theta-stars
  Gamma <- Gamma/rowSums(Gamma) #devide by row sums so that entries of a row sum to 1 (transformation is inverse logit link)
  delta <- solve(t(diag(N)-Gamma+1),rep(1,N)) #stationary distribution erstellen
  mu.tort <- exp(theta.star[3:4]) #Mittelwert
  sigma <- exp(theta.star[5:6]) #Varianz
  allprobs <- matrix(1,dim(x)[1],N)
  ind <- which(!is.na(x$log.tort)) # indices of non-missing tortuosities
  allprobs[ind,] <- cbind(dgamma(x$log.tort[ind],shape=mu.tort[1]^2/sigma[1]^2,scale=sigma[1]^2/mu.tort[1]),
                          dgamma(x$log.tort[ind],shape=mu.tort[2]^2/sigma[2]^2,scale=sigma[2]^2/mu.tort[2]))
  foo <- delta%*%diag(allprobs[1,])
  l <- log(sum(foo))
  phi <- foo/sum(foo)
  for (t in 2:dim(x)[1]){
    foo <- phi%*%Gamma%*%diag(allprobs[t,])
    l <- l+log(sum(foo))
    phi <- foo/sum(foo)
  }
  return(-l)
}

N=2

# finding starting values
hist(data$log.tort, breaks=400, main = "Histogram of log(tortuosity)", xlab = "log(tort)", xlim=c(0,0.1))
#starting values
theta.star <- c(rep(-2,(N-1)*N),log(c(0.005,0.04)),log(c(0.005,0.01)))

# numerical maximization 
mod.tort <- nlm(mllk.tort,theta.star,x=data,N=N,print.level=1,iterlim=500)
theta.star.mle = mod.tort$estimate

#back-transformation
Gamma <- diag(N)
Gamma[!Gamma] <- exp(theta.star.mle[1:((N-1)*N)])
Gamma <- Gamma/rowSums(Gamma)
delta <- solve(t(diag(N)-Gamma+1),rep(1,N))
mu.tort <- exp(theta.star.mle[(N-1)*N+1:N])
sigma <- exp(theta.star.mle[(N-1)*N+(N+1):(2*N)])

round(Gamma, 4) #Matrix auf 4 Nachkommastellen gerundet
mu.tort
sigma
delta


#### 2-States HMM with speed grafische Darstellung ####
# State dependent distributions
hist(data$log.tort,probability=TRUE,breaks=500,col="light grey",xlab="log(tort)",main="State-dependent distributions", xlim= c(0,0.1))
curve(delta[1]*dgamma(x,shape=mu.tort[1]^2/sigma[1]^2,scale=sigma[1]^2/mu.tort[1]),add=TRUE,col="#E69F00", lwd=2)
curve(delta[2]*dgamma(x,shape=mu.tort[2]^2/sigma[2]^2,scale=sigma[2]^2/mu.tort[2]),add=TRUE,col="#56B4E9", lwd=2)
curve(delta[1]*dgamma(x,shape=mu.tort[1]^2/sigma[1]^2,scale=sigma[1]^2/mu.tort[1])
      +delta[2]*dgamma(x,shape=mu.tort[2]^2/sigma[2]^2,scale=sigma[2]^2/mu.tort[2]),add=TRUE,col="black", lwd=2, lty=2)
colours <- c("#E69F00", "#56B4E9", "black")
legend("topright", inset = c(0,0), legend= c("State 1","State 2","Sum of densities"), pch = 16, col=colours)


#### 2-States HMM with speed global decoding ####

viterbi <- function(x,mu.tort,sigma,Gamma,delta){
  n <- length(x)
  allprobs <- matrix(1,n,2)
  ind <- which(!is.na(x))
  allprobs[ind,] <- cbind(dgamma(x[ind],shape=mu.tort[1]^2/sigma[1]^2,scale=sigma[1]^2/mu.tort[1]),
                          dgamma(x[ind],shape=mu.tort[2]^2/sigma[2]^2,scale=sigma[2]^2/mu.tort[2]))
  xi <- matrix(0,n,2)
  foo <- delta*allprobs[1,]
  xi[1,] <- foo/sum(foo)
  for (t in 2:n) {
    foo <- apply(xi[t-1,]*Gamma,2,max)*allprobs[t,]
    xi[t,] <- foo/sum(foo)
  }
  iv <- numeric(n)
  iv[n] <- which.max(xi[n,])
  for (t in (n-1):1){
    iv[t] <- which.max(Gamma[,iv[t+1]]*xi[t,])
  }
  iv
}

#### Global decoding für jedes Tier einzeln, mit festgesetzten Limits
par(mfrow=c(2,1))
colors <- c("#E69F00", "#56B4E9")
for(i in unique(data$ID)){
x=data$log.tort[which(data$ID==i)]
vitstates2 <- viterbi(x,mu.tort,sigma,Gamma,delta)
plot(data$y[which(data$ID==i)]~data$x[which(data$ID==i)],main=i,xlab="x",ylab="y",col=colors[vitstates2],type="p", pch=20)
plot(x,xlab="time",ylab="log(tort)",col=colors[vitstates2],type="p", pch=20, xlim=c(0,3000), ylim=c(0,1))
}




#### Global decoding für jedes Tier einzeln (umständliche Version!)

#Namen der Tiere
data_Tabelle_Tiere <- data.frame(table(dat$ID))
data_Anzahl_Tiere_groß <- data_Tabelle_Tiere[data_Tabelle_Tiere$Freq > 700,]
data_Anzahl_Tiere_groß$Var1

oneID<-"Tern-h2-17"
oneID<-"Tern-h2-18"
oneID<-"Tern-h2-19"
oneID<-"Tern-h2-28"
oneID<-"Tern-h2-30"
oneID<-"Tern-h2-32"
oneID<-"Tern-h2-36"
oneID<-"Tern-h2-41"
oneID<-"Tern-h2-49"
oneID<-"Tern-h2-51"
oneID<-"Tern-h2-63"
oneID<-"Tern-h2-67"
oneID<-"Tern-h2-68"
oneID<-"Tern-h2-69"
oneID<-"Tern-h2-70"
oneID<-"Tern-h2-78"
oneID<-"Tern-h2-92"
oneID<-"Tern-h2-106"
oneID<-"Tern-h2-115"

x=data$log.tort[which(data$ID==oneID)]
vitstates2 <- viterbi(x,mu.tort,sigma,Gamma,delta)
colors <- c("#E69F00", "#56B4E9")
plot(x,main=oneID,xlab="time",ylab="log(tort)",col=colors[vitstates2],type="p", pch=20)
plot(data$y[which(data$ID==oneID)]~data$x[which(data$ID==oneID)],main=oneID,xlab="x",ylab="y",col=colors[vitstates2],type="p", pch=20)

## Limits Tortuosity
# Zeitreihe: ylim: 0 - 1.5; xlim: 0-3000
# x~y Plot: ylim: -80 - 50; xlim: -80 - 80
x=data$log.tort[which(data$ID==oneID)]
vitstates2 <- viterbi(x,mu.tort,sigma,Gamma,delta)
colors <- c("#E69F00", "#56B4E9")
plot(x,main=oneID,xlab="time",ylab="log(tort)",col=colors[vitstates2],type="p", pch=20, xlim=c(0,3000), ylim=c(0,1.5))
plot(data$y[which(data$ID==oneID)]~data$x[which(data$ID==oneID)],main=oneID,xlab="x",ylab="y",col=colors[vitstates2],type="p", pch=20, xlim=c(-80,80), ylim=c(-80,50))


####fitting 3-States HMM with speed ####

#noch nicht fehlerfrei!!!
mllk.tort3 <- function(theta.star3, x, N){
  Gamma3 <- diag(N)  
  Gamma3[!Gamma3] <- exp(theta.star3[1:((N-1)*N)])
  Gamma3 <- Gamma3/rowSums(Gamma3) 
  delta3 <- solve(t(diag(N)-Gamma3+1),rep(1,N)) 
  mu.tort3 <- exp(theta.star3[(N-1)*N+1:N])  #Mittelwert
  sigma.tort3 <- exp(theta.star3[(N-1)*N+(N+1):(2*N)]) #Varianz
  allprobs <- matrix(1,dim(x)[1],N)
  ind <- which(!is.na(x$log.tort)) 
  allprobs[ind,] <- cbind(dgamma(x$log.tort[ind], shape=mu.tort3[1]^2/sigma.tort3[1]^2, scale=sigma.tort3[1]^2/mu.tort3[1]),
                          dgamma(x$log.tort[ind], shape=mu.tort3[2]^2/sigma.tort3[2]^2, scale=sigma.tort3[2]^2/mu.tort3[2]), 
                          dgamma(x$log.tort[ind], shape=mu.tort3[3]^2/sigma.tort3[3]^2, scale=sigma.tort3[3]^2/mu.tort3[3]))
  foo <- delta3%*%diag(allprobs[1,])
  l <- log(sum(foo))
  phi <- foo/sum(foo)
  for (t in 2:dim(x)[1]){
    foo <- phi%*%Gamma3%*%diag(allprobs[t,])
    l <- l+log(sum(foo))
    phi <- foo/sum(foo)
  }
  return(-l)
}

N=3

theta.star3 <- c(rep(-2,(N-1)*N),log(c(0.03,0.1,0.3)),log(c(0.01,0.05,0.075)))
mod.tort3 <- nlm(mllk.tort3,theta.star3,x=data,N=N,print.level=1,iterlim=500)
theta.star3.mle <- mod.tort3$estimate

Gamma3 <- diag(N)
Gamma3[!Gamma3] <- exp(theta.star3.mle[1:((N-1)*N)])
Gamma3 <- Gamma3/rowSums(Gamma3)
delta3 <- solve(t(diag(N)-Gamma3+1),rep(1,N))
mu.tort3 <- exp(theta.star3.mle[(N-1)*N+1:N])
sigma.tort3 <- exp(theta.star3.mle[(N-1)*N+(N+1):(2*N)])

round(Gamma3, 4) # Matrix auf 4 Nachkommastellen gerundet
mu.tort3
sigma.tort3
delta3



#### 3-States HMM with speed grafische Darstellung ####
# State dependent distributions
hist(data$log.tort,probability=TRUE,breaks=500,col="light grey",xlab="log(tort)",main="State-dependent distributions", xlim= c(0,0.1))
curve(delta3[1]*dgamma(x,shape=mu.tort3[1]^2/sigma.tort3[1]^2,scale=sigma.tort3[1]^2/mu.tort3[1]),add=TRUE,col="#E69F00", lwd=2) 
curve(delta3[2]*dgamma(x,shape=mu.tort3[2]^2/sigma.tort3[2]^2,scale=sigma.tort3[2]^2/mu.tort3[2]),add=TRUE,col="#56B4E9", lwd=2)
curve(delta3[3]*dgamma(x,shape=mu.tort3[3]^2/sigma.tort3[3]^2,scale=sigma.tort3[3]^2/mu.tort3[3]),add=TRUE,col="#009E73", lwd=2)
#marginal distribution
colours <- c("#E69F00", "#56B4E9", "#009E73", "black")
curve(delta3[1]*dgamma(x,shape=mu.tort3[1]^2/sigma.tort3[1]^2,scale=sigma.tort3[1]^2/mu.tort3[1])
      +delta3[2]*dgamma(x,shape=mu.tort3[2]^2/sigma.tort3[2]^2,scale=sigma.tort3[2]^2/mu.tort3[2])
      +delta3[3]*dgamma(x,shape=mu.tort3[3]^2/sigma.tort3[3]^2,scale=sigma.tort3[3]^2/mu.tort3[3]),
      add=TRUE,col="black", lwd=2, lty=2)
legend("topright", inset = c(0,0), legend= c("State 1","State 2","State 3","Sum of densities"), pch = 16, col=colours)


#### 3-States HMM with speed global decoding ####
viterbi3 <- function(x,mu.tort3,sigma.tort3,Gamma3,delta3){
  n <- length(x)
  allprobs <- matrix(1,n,3)
  ind <- which(!is.na(x))
  allprobs[ind,] <- cbind(dgamma(x[ind], shape=mu.tort3[1]^2/sigma.tort3[1]^2, scale=sigma.tort3[1]^2/mu.tort3[1]),
                          dgamma(x[ind], shape=mu.tort3[2]^2/sigma.tort3[2]^2, scale=sigma.tort3[2]^2/mu.tort3[2]), 
                          dgamma(x[ind], shape=mu.tort3[3]^2/sigma.tort3[3]^2, scale=sigma.tort3[3]^2/mu.tort3[3]))
  xi <- matrix(0,n,3)
  foo <- delta3*allprobs[1,]
  xi[1,] <- foo/sum(foo)
  for (t in 2:n) {
    foo <- apply(xi[t-1,]*Gamma3,2,max)*allprobs[t,]
    xi[t,] <- foo/sum(foo)
  }
  iv <- numeric(n)
  iv[n] <- which.max(xi[n,])
  for (t in (n-1):1){
    iv[t] <- which.max(Gamma3[,iv[t+1]]*xi[t,])
  }
  iv
}


#### Global decoding für jedes Tier einzeln

#Namen der Tiere
data_Tabelle_Tiere <- data.frame(table(dat$ID))
data_Anzahl_Tiere_groß <- data_Tabelle_Tiere[data_Tabelle_Tiere$Freq > 700,]
data_Anzahl_Tiere_groß$Var1

oneID<-"Tern-h2-17"
oneID<-"Tern-h2-18"
oneID<-"Tern-h2-19"
oneID<-"Tern-h2-28"
oneID<-"Tern-h2-30"
oneID<-"Tern-h2-32"
oneID<-"Tern-h2-36"
oneID<-"Tern-h2-41"
oneID<-"Tern-h2-49"
oneID<-"Tern-h2-51"
oneID<-"Tern-h2-63"
oneID<-"Tern-h2-67"
oneID<-"Tern-h2-68"
oneID<-"Tern-h2-69"
oneID<-"Tern-h2-70"
oneID<-"Tern-h2-78"
oneID<-"Tern-h2-92"
oneID<-"Tern-h2-106"
oneID<-"Tern-h2-115"

x=data$log.tort[which(data$ID==oneID)]
vitstates3 <- viterbi3(x,mu.tort3,sigma.tort3,Gamma3,delta3)
colors <- c("#E69F00", "#56B4E9","#009E73")
plot(data$y[which(data$ID==oneID)]~data$x[which(data$ID==oneID)],main=oneID,xlab="x",ylab="y",col=colors[vitstates2],type="p", pch=20)
plot(x,main=oneID,xlab="time",ylab="step",col=colors[vitstates3],type="p", pch=20)



