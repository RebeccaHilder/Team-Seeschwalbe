#### with covariates ####
### dummy-covariate slick
mllk.slick <- function(theta.star,x){
  mu.tort <- exp(theta.star[1:2])
  sigma <- exp(theta.star[3:4])
  delta <- c(plogis(theta.star[5]),1-plogis(theta.star[5]))
  beta <- cbind(theta.star[6:7],theta.star[8:9])
  allprobs <- matrix(1,dim(x)[1],2)
  ind <- which(!is.na(x$log.tort)) # indices of non-missing step lengths
  allprobs[ind,] <- cbind(dgamma(x$log.tort[ind],shape=mu.tort[1]^2/sigma[1]^2,scale=sigma[1]^2/mu.tort[1]),
                          dgamma(x$log.tort[ind],shape=mu.tort[2]^2/sigma[2]^2,scale=sigma[2]^2/mu.tort[2]))
  #for (j in 1:2){
  #  allprobs[,j] <- dgamma(x$step,shape=mu.step[j]^2/sigma[j]^2,scale=sigma[j]^2/mu.step[j])
  #}
  foo <- delta%*%diag(allprobs[1,])
  l <- log(sum(foo))
  phi <- foo/sum(foo)
  for (t in 2:dim(x)[1]){
    eta <- beta[,1]+beta[,2]*x[t,"slick"]
    Gamma <- diag(2)
    # tpm has to be updated after every new estimation of the beta values
    Gamma[!Gamma] <- exp(eta) # assign values to the off-diagonal entries of the Gamma-matrix
    Gamma <- Gamma/rowSums(Gamma)
    foo <- phi%*%Gamma%*%diag(allprobs[t,])
    l <- l+log(sum(foo))
    phi <- foo/sum(foo)
  }
  return(-l)
}

N=2

#starting values
delta0 <- 0.5
# choose beta0 such that the diagonal elements of the resulting Gamma matrix will be highest (similar to starting values for gamma_ij)
beta0 <- rep(-2,N*(N-1))
# here my initial guess is that our covariate has no effect on the state process and hence I set all beta1 values to zero
beta1 <- rep(0,N*(N-1))

theta.star <- c(log(mu.tort),log(sigma),qlogis(delta0), beta0, beta1)
mod_slick <- nlm(mllk.slick,theta.star,x=data,print.level=2, iterlim=500)

# natural parameters
mu_slick <- exp(mod_slick$estimate[1:2])
sigma_slick <- exp(mod_slick$estimate[3:4])
mu_slick
sigma_slick

### covariate time-to-slick
# change NAs to infinity
data$time_to_slick[is.na(data$time_to_slick)]<-Inf
# new column with inverse of time-to-slick
data$inverse.tts <- 1/(data$time_to_slick+1) # 1=near slick, 0=far away
hist(data$inverse.tts)

mllk.tts <- function(theta.star,x){
  mu.tort <- exp(theta.star[1:2])
  sigma <- exp(theta.star[3:4])
  delta <- c(plogis(theta.star[5]),1-plogis(theta.star[5]))
  beta <- cbind(theta.star[6:7],theta.star[8:9])
  allprobs <- matrix(1,dim(x)[1],2)
  ind <- which(!is.na(x$log.tort)) # indices of non-missing step lengths
  allprobs[ind,] <- cbind(dgamma(x$log.tort[ind],shape=mu.tort[1]^2/sigma[1]^2,scale=sigma[1]^2/mu.tort[1]),
                          dgamma(x$log.tort[ind],shape=mu.tort[2]^2/sigma[2]^2,scale=sigma[2]^2/mu.tort[2]))
  foo <- delta%*%diag(allprobs[1,])
  l <- log(sum(foo))
  phi <- foo/sum(foo)
  for (t in 2:dim(x)[1]){
    eta <- beta[,1]+beta[,2]*x[t,"inverse.tts"]
    Gamma <- diag(2)
    # tpm has to be updated after every new estimation of the beta values
    Gamma[!Gamma] <- exp(eta) # assign values to the off-diagonal entries of the Gamma-matrix
    Gamma <- Gamma/rowSums(Gamma)
    foo <- phi%*%Gamma%*%diag(allprobs[t,])
    l <- l+log(sum(foo))
    phi <- foo/sum(foo)
  }
  return(-l)
}

N=2

#starting values
delta0 <- 0.5
# choose beta0 such that the diagonal elements of the resulting Gamma matrix will be highest (similar to starting values for gamma_ij)
beta0 <- rep(-2,N*(N-1))
# here my initial guess is that our covariate has no effect on the state process and hence I set all beta1 values to zero
beta1 <- rep(0,N*(N-1))

theta.star <- c(log(mu.tort),log(sigma),qlogis(delta0), beta0, beta1)
mod_tts <- nlm(mllk.tts,theta.star,x=data,print.level=2, iterlim=500)

# natural parameters
mu_tts <- exp(mod_tts$estimate[1:2])
sigma_tts <- exp(mod_tts$estimate[3:4])
mu_tts
sigma_tts


#### model selection ####
## AIC
aic <- numeric(3)
aic[1] <- 2*mod.tort$minimum + 2*length(mod.tort$estimate)
aic[2] <- 2*mod_slick$minimum + 2*length(mod_slick$estimate)
aic[3] <- 2*mod_tts$minimum + 2*length(mod_tts$estimate)
aic
which.min(aic) 
#plot(1:2,aic,type='b',main='AIC values',xlab='number of covariates',ylab='AIC')


## BIC
bic <- numeric(3)
T <- dim(data)[1]
bic[1] <- 2*mod.tort$minimum + log(T)*length(mod.tort$estimate)
bic[2] <- 2*mod_slick$minimum + log(T)*length(mod_slick$estimate)
bic[3] <- 2*mod_tts$minimum + log(T)*length(mod_tts$estimate)
bic
which.min(bic)
