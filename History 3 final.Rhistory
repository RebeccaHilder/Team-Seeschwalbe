tts.seq <- seq(0,1, length = 1000)
for (k in 1:1000) {
eta <- beta0_tts + beta1_tts*tts.seq[k]
Gamma.tts3 <- diag(3)
Gamma.tts3[!Gamma.tts3] <- exp(eta)
Gamma.tts3 <- Gamma.tts3/rowSums(Gamma.tts3)
Gamma22[k] <- Gamma.tts3[2,2]
}
# changing prob 3 to 3
Gamma33 <- rep(NA,1000)
tts.seq <- seq(0,1, length = 1000)
for (k in 1:1000) {
eta <- beta0_tts + beta1_tts*tts.seq[k]
Gamma.tts3 <- diag(3)
Gamma.tts3[!Gamma.tts3] <- exp(eta)
Gamma.tts3 <- Gamma.tts3/rowSums(Gamma.tts3)
Gamma33[k] <- Gamma.tts3[3,3]
}
# changing prob 1 to 2
Gamma12 <- rep(NA,1000)
tts.seq <- seq(0,1, length = 1000)
for (k in 1:1000) {
eta <- beta0_tts + beta1_tts*tts.seq[k]
Gamma.tts3 <- diag(3)
Gamma.tts3[!Gamma.tts3] <- exp(eta)
Gamma.tts3 <- Gamma.tts3/rowSums(Gamma.tts3)
Gamma12[k] <- Gamma.tts3[1,2]
}
# changing prob 1 to 3
Gamma13 <- rep(NA,1000)
tts.seq <- seq(0,1, length = 1000)
for (k in 1:1000) {
eta <- beta0_tts + beta1_tts*tts.seq[k]
Gamma.tts3 <- diag(3)
Gamma.tts3[!Gamma.tts3] <- exp(eta)
Gamma.tts3 <- Gamma.tts3/rowSums(Gamma.tts3)
Gamma13[k] <- Gamma.tts3[1,3]
}
# changing prob 2 to 1
Gamma21 <- rep(NA,1000)
tts.seq <- seq(0,1, length = 1000)
for (k in 1:1000) {
eta <- beta0_tts + beta1_tts*tts.seq[k]
Gamma.tts3 <- diag(3)
Gamma.tts3[!Gamma.tts3] <- exp(eta)
Gamma.tts3 <- Gamma.tts3/rowSums(Gamma.tts3)
Gamma21[k] <- Gamma.tts3[2,1]
}
# changing prob 2 to 3
Gamma23 <- rep(NA,1000)
slick.seq <- seq(0,1, length = 1000)
tts.seq <- seq(0,1, length = 1000)
for (k in 1:1000) {
eta <- beta0_tts + beta1_tts*tts.seq[k]
Gamma.tts3 <- diag(3)
Gamma.tts3[!Gamma.tts3] <- exp(eta)
Gamma.tts3 <- Gamma.tts3/rowSums(Gamma.tts3)
Gamma23[k] <- Gamma.tts3[2,3]
}
# changing prob 3 to 1
Gamma31 <- rep(NA,1000)
tts.seq <- seq(0,1, length = 1000)
for (k in 1:1000) {
eta <- beta0_tts + beta1_tts*tts.seq[k]
Gamma.tts3 <- diag(3)
Gamma.tts3[!Gamma.tts3] <- exp(eta)
Gamma.tts3 <- Gamma.tts3/rowSums(Gamma.tts3)
Gamma31[k] <- Gamma.tts3[3,1]
}
# changing prob 3 to 2
Gamma32 <- rep(NA,1000)
tts.seq <- seq(0,1, length = 1000)
for (k in 1:1000) {
eta <- beta0_tts + beta1_tts*tts.seq[k]
Gamma.tts3 <- diag(3)
Gamma.tts3[!Gamma.tts3] <- exp(eta)
Gamma.tts3 <- Gamma.tts3/rowSums(Gamma.tts3)
Gamma32[k] <- Gamma.tts3[3,2]
}
par(mfrow = c(3,3))
plot(Gamma11 ~ tts.seq, main = "Gamma11", ylab = "P(1->1)", xlab = "tts", ylim = c(0.95,1),
type="l", lwd=5)
plot(Gamma12 ~ tts.seq, main = "Gamma12", ylab = "P(1->2)", xlab = "tts", ylim = c(0,0.05),
type="l", lwd=5)
plot(Gamma13 ~ tts.seq, main = "Gamma13", ylab = "P(1->3)", xlab = "tts", ylim = c(0,0.05),
type="l", lwd=5)
plot(Gamma21 ~ tts.seq, main = "Gamma21", ylab = "P(2->1)", xlab = "tts", ylim = c(0,0.05),
type="l", lwd=5)
plot(Gamma22 ~ tts.seq, main = "Gamma22", ylab = "P(2->2)", xlab = "tts", ylim = c(0.95,1),
type="l", lwd=5)
plot(Gamma23 ~ tts.seq, main = "Gamma23", ylab = "P(2->3)", xlab = "tts", ylim = c(0,0.05),
type="l", lwd=5)
plot(Gamma31 ~ tts.seq, main = "Gamma31", ylab = "P(3->1)", xlab = "tts", ylim = c(0,0.05),
type="l", lwd=5)
plot(Gamma32 ~ tts.seq, main = "Gamma32", ylab = "P(3->2)", xlab = "tts", ylim = c(0,0.05),
type="l", lwd=5)
plot(Gamma33 ~ tts.seq, main = "Gamma33", ylab = "P(3->3)", xlab = "tts", ylim = c(0.95,1),
type="l", lwd=5)
par(mfrow = c(1,1))
set.seed(7265)
n <- 20177
x <- s <- rep(NA,n)
s[1] <- sample(1:3,size=1,prob=delta3)
x[1] <- rgamma(1,shape=mu.tort3[s[1]]^2/sigma.tort3[s[1]]^2,scale=sigma.tort3[s[1]]^2/mu.tort3[s[1]])
for (t in 2:n){
s[t] <- sample(1:3,size=1,prob=Gamma3[s[t-1],])
x[t] <- rgamma(1,shape=mu.tort3[s[t]]^2/sigma.tort3[s[t]]^2,scale=sigma.tort3[s[t]]^2/mu.tort3[s[t]])
}
# graphical comparison
par(mfrow = c(1,2))
hist(x,xlim=c(0,0.2),breaks=seq(0,3,length=200)) #Simulated data
hist(data$log.tort,xlim=c(0,0.2),breaks=seq(0,3,length=200)) #Emprical data
d <- dthmm(data$log.tort, Gamma3, delta3, "gamma",
list(shape=c(mu.tort3[1]^2/sigma.tort3[1]^2,mu.tort3[2]^2/sigma.tort3[2]^2,mu.tort3[3]^2/sigma.tort3[3]^2),
scale=c(sigma.tort3[1]^2/mu.tort3[1],sigma.tort3[2]^2/mu.tort3[2],sigma.tort3[3]^2/mu.tort3[3])))
resids <- residuals(d)
which(resids==Inf) #no values with 3 states model
#Remove outliers
data.resid <- data[-17092,] # remove 17092
data.resid <- data.resid[-17092,] # remove 17092 (Have to be repeated, cause numbering changes)
d <- dthmm(data.resid$log.tort, Gamma3, delta3, "gamma",
list(shape=c(mu.tort3[1]^2/sigma.tort3[1]^2,mu.tort3[2]^2/sigma.tort3[2]^2,mu.tort3[3]^2/sigma.tort3[3]^2),
scale=c(sigma.tort3[1]^2/mu.tort3[1],sigma.tort3[2]^2/mu.tort3[2],sigma.tort3[3]^2/mu.tort3[3])))
resids <- residuals(d)
hist(resids, freq=F)
m <- mean(resids)
s <-  sd(resids)
x <- resids
curve(dnorm(x,m,s),add=TRUE,lwd=3, col="blue")
qqnorm(resids)
qqline(resids)
#Time series of pseudo-residuals
plot(resids)
#ACF of the pseudo-residuals
acf(resids)
par(mfrow = c(1,1))
plot(resids)
plot(resids, col=ifelse(resids>=4,"orange","black"), pch=ifelse(resids>=4,1,1))
data.resid$residuals <- resids
which(resids>4)
table(data.resid[which(resids>4),]$ID)
data.resid.outlier <- rbind(data.resid[which(resids>4),])
plot(data.resid.outlier$residuals)
##Time series decoded for log(tort) of all outliers
plot(data.resid.outlier$log.tort,xlab="time",ylab="log(tort)",col=colors[vitstates3],type="p", pch=20)#, ylim=c(0,1))
legend("topright", inset = c(0,0), legend= c("State 1","State 2", "State 3"), pch = 16, col=colors)
table(data.resid.outlier$ID)
T_h2_48 <- which(data.resid.outlier$ID=="Tern-h2-48")
data.resid.outlier <- data.resid.outlier[-56,] # remove 56
T_h2_80 <- which(data.resid.outlier$ID=="Tern-h2-80")
data.resid.outlier <- data.resid.outlier[-92,] # remove 92
par(mfrow = c(3,3))
##Time series decoded separately
colors <- c("#E69F00", "#009E73", "#56B4E9")
for(i in unique(data.resid.outlier$ID)){
x=data.resid.outlier$log.tort[which(data.resid.outlier$ID==i)]
vitstates3 <- viterbi3(x, mu.tort3, sigma.tort3, Gamma3, delta3)
plot(x,xlab="time",ylab="log(tort)",main=i,col=colors[vitstates3],type="p",lwd=5, pch=20) # , ylim=c(0,2.5))
legend("bottomright", inset = c(0,0), legend= c("State 1","State 2", "State 3"), pch = 16, col=colors)
}
(-1)*2*mod_tts3$minimum-(-1)*2*mod.tort3$minimum #84.40511
qchisq(0.95,6) #12.59159
hist(data$log.tort, probability = TRUE, breaks = 500, col = "light grey", xlab = "log(tort)",
main = "State-dependent distributions", xlim = c(0,0.1))
colors <- c("#E69F00", "#009E73", "#56B4E9", "black")
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1]), add = TRUE, col = colors[1], lwd = 2 , n=1001)
curve(delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2]), add = TRUE, col = colors[2], lwd = 2 , n=1001)
curve(delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]), add = TRUE, col = colors[3], lwd = 2 , n=1001)
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1])
+ delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2])
+ delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]),
add = TRUE, col = colors[4], lwd = 2, lty = 2 , n=1001)
legend("topright", inset = c(0,0), legend = c("State 1: flying", "State 2: searching/hovering",
"State 3: foraging", "Marginal distribution"),
pch = 16, col = colors)
par(mfrow = c(1,1))
hist(data$log.tort, probability = TRUE, breaks = 500, col = "light grey", xlab = "log(tort)",
main = "State-dependent distributions", xlim = c(0,0.1))
colors <- c("#E69F00", "#009E73", "#56B4E9", "black")
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1]), add = TRUE, col = colors[1], lwd = 2 , n=1001)
curve(delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2]), add = TRUE, col = colors[2], lwd = 2 , n=1001)
curve(delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]), add = TRUE, col = colors[3], lwd = 2 , n=1001)
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1])
+ delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2])
+ delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]),
add = TRUE, col = colors[4], lwd = 2, lty = 2 , n=1001)
legend("topright", inset = c(0,0), legend = c("State 1: flying", "State 2: searching/hovering",
"State 3: foraging", "Marginal distribution"),
pch = 16, col = colors)
hist(data$log.tort, probability = F, breaks = 500, col = "light grey", xlab = "log(tort)",
main = "State-dependent distributions", xlim = c(0,0.1))
colors <- c("#E69F00", "#009E73", "#56B4E9", "black")
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1]), add = TRUE, col = colors[1], lwd = 2 , n=1001)
curve(delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2]), add = TRUE, col = colors[2], lwd = 2 , n=1001)
curve(delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]), add = TRUE, col = colors[3], lwd = 2 , n=1001)
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1])
+ delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2])
+ delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]),
add = TRUE, col = colors[4], lwd = 2, lty = 2 , n=1001)
legend("topright", inset = c(0,0), legend = c("State 1: flying", "State 2: searching/hovering",
"State 3: foraging", "Marginal distribution"),
pch = 16, col = colors)
hist(data$log.tort, probability = T, breaks = 500, col = "light grey", xlab = "log(tort)",
main = "State-dependent distributions", xlim = c(0,0.1))
colors <- c("#E69F00", "#009E73", "#56B4E9", "black")
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1]), add = TRUE, col = colors[1], lwd = 2 , n=1001)
curve(delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2]), add = TRUE, col = colors[2], lwd = 2 , n=1001)
curve(delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]), add = TRUE, col = colors[3], lwd = 2 , n=1001)
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1])
+ delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2])
+ delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]),
add = TRUE, col = colors[4], lwd = 2, lty = 2 , n=1001)
legend("topright", inset = c(0,0), legend = c("State 1: flying", "State 2: searching/hovering",
"State 3: foraging", "Marginal distribution"),
pch = 16, col = colors)
hist(data$log.tort, probability = T, breaks = 500, col = "light grey", xlab = "log(tort)",
main = "State-dependent distributions", xlim = c(0,0.1))
colors <- c("#E69F00", "#009E73", "#56B4E9", "black")
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1]), add = TRUE, col = colors[1], lwd = 2 , n=1001)
curve(delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2]), add = TRUE, col = colors[2], lwd = 2 , n=1001)
curve(delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]), add = TRUE, col = colors[3], lwd = 2 , n=1001)
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1])
+ delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2])
+ delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]),
add = TRUE, col = colors[4], lwd = 2, lty = 2 )
legend("topright", inset = c(0,0), legend = c("State 1: flying", "State 2: searching/hovering",
"State 3: foraging", "Marginal distribution"),
pch = 16, col = colors)
hist(data$log.tort, probability = T, breaks = 500, col = "light grey", xlab = "log(tort)",
main = "State-dependent distributions", xlim = c(0,0.1))
colors <- c("#E69F00", "#009E73", "#56B4E9", "black")
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1]), add = TRUE, col = colors[1], lwd = 2 , n=1001)
curve(delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2]), add = TRUE, col = colors[2], lwd = 2 , n=1001)
curve(delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]), add = TRUE, col = colors[3], lwd = 2 , n=1001)
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1])
+ delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2])
+ delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]),
add = TRUE, col = colors[4], lwd = 2, lty = 2 , n = 1001)
legend("topright", inset = c(0,0), legend = c("State 1: flying", "State 2: searching/hovering",
"State 3: foraging", "Marginal distribution"),
pch = 16, col = colors)
View(data)
set.seed(7265)
n <- 65181
x <- s <- rep(NA,n)
s[1] <- sample(1:3,size=1,prob=delta3)
x[1] <- rgamma(1,shape=mu.tort3[s[1]]^2/sigma.tort3[s[1]]^2,scale=sigma.tort3[s[1]]^2/mu.tort3[s[1]])
for (t in 2:n){
s[t] <- sample(1:3,size=1,prob=Gamma3[s[t-1],])
x[t] <- rgamma(1,shape=mu.tort3[s[t]]^2/sigma.tort3[s[t]]^2,scale=sigma.tort3[s[t]]^2/mu.tort3[s[t]])
}
# graphical comparison
par(mfrow = c(1,2))
hist(x,xlim=c(0,0.2),breaks=seq(0,3,length=200)) #Simulated data
hist(data$log.tort,xlim=c(0,0.2),breaks=seq(0,3,length=200)) #Emprical data
save.image("~/Documents/Uni/Master StatWi/Seeschwalben/Environment 3.RData")
savehistory("~/Documents/Uni/Master StatWi/Seeschwalben/History 3.Rhistory")
hist(data$log.tort, probability = T, breaks = 500, col = "light grey", xlab = "log(tort)",
main = "State-dependent distributions", xlim = c(0,0.1))
colors <- c("#E69F00", "#009E73", "#56B4E9", "black")
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1]), add = TRUE, col = colors[1], lwd = 2, n=1001 )
curve(delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2]), add = TRUE, col = colors[2], lwd = 2, n=1001 )
curve(delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]), add = TRUE, col = colors[3], lwd = 2, n=1001 )
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1])
+ delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2])
+ delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]),
add = TRUE, col = colors[4], lwd = 2, lty = 2, n=1001)
legend("topright", inset = c(0,0), legend = c("State 1: flying", "State 2: searching/hovering",
"State 3: foraging", "Marginal distribution"),
pch = 16, col = colors)
mllk.tort3 <- function(theta.star3, x, N){
Gamma3 <- diag(N)
Gamma3[!Gamma3] <- exp(theta.star3[1:((N-1)*N)])
Gamma3 <- Gamma3/rowSums(Gamma3)
delta3 <- solve(t(diag(N)-Gamma3+1),rep(1,N))
mu.tort3 <- cumsum(exp(theta.star3[(N-1)*N+1:N]))  #Mittelwert
sigma.tort3 <- exp(theta.star3[(N-1)*N+(N+1):(2*N)]) #Varianz
allprobs <- matrix(1,dim(x)[1],N)
ind <- which(!is.na(x$log.tort))
allprobs[ind,] <- cbind(dgamma(x$log.tort[ind], shape=mu.tort3[1]^2/sigma.tort3[1]^2,
scale=sigma.tort3[1]^2/mu.tort3[1]),
dgamma(x$log.tort[ind], shape=mu.tort3[2]^2/sigma.tort3[2]^2,
scale=sigma.tort3[2]^2/mu.tort3[2]),
dgamma(x$log.tort[ind], shape=mu.tort3[3]^2/sigma.tort3[3]^2,
scale=sigma.tort3[3]^2/mu.tort3[3]))
foo <- delta3%*%diag(allprobs[1,])
l <- log(sum(foo))
phi <- foo/sum(foo)
for (t in 2:dim(x)[1]){
foo <- phi%*%Gamma3%*%diag(allprobs[t,])
l <- l+log(sum(foo))
phi <- foo/sum(foo)
}
return(-l)
}
N=3
# Finding starting values
hist(data$log.tort, breaks=1000, main = "Histogram of log(tortuosity)", xlab = "log(tort)", xlim=c(0,0.1))
# Starting values
theta.star3 <- c(rep(-2,(N-1)*N),log(c(0.01,0.02,0.03)),log(c(0.005,0.01,0.02)))
# numerical maximization
mod.tort3 <- nlm(mllk.tort3,theta.star3,x=data,N=N,print.level=2,iterlim=500, stepmax = 10) # 91 iterations
Gamma3 <- diag(N)
Gamma3[!Gamma3] <- exp(theta.star3.mle[1:((N-1)*N)])
Gamma3 <- Gamma3/rowSums(Gamma3)
delta3 <- solve(t(diag(N)-Gamma3+1),rep(1,N))
mu.tort3 <- cumsum(exp(theta.star3.mle[(N-1)*N+1:N]))
sigma.tort3 <- exp(theta.star3.mle[(N-1)*N+(N+1):(2*N)])
round(Gamma3, 4)
mu.tort3
sigma.tort3
delta3
hist(data$log.tort, probability = T, breaks = 500, col = "light grey", xlab = "log(tort)",
main = "State-dependent distributions", xlim = c(0,0.1))
colors <- c("#E69F00", "#009E73", "#56B4E9", "black")
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1]), add = TRUE, col = colors[1], lwd = 2, n=1001 )
curve(delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2]), add = TRUE, col = colors[2], lwd = 2, n=1001 )
curve(delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]), add = TRUE, col = colors[3], lwd = 2, n=1001 )
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1])
+ delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2])
+ delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]),
add = TRUE, col = colors[4], lwd = 2, lty = 2, n=1001)
legend("topright", inset = c(0,0), legend = c("State 1: flying", "State 2: searching/hovering",
"State 3: foraging", "Marginal distribution"),
pch = 16, col = colors)
mllk.tort3 <- function(theta.star3, x, N){
Gamma3 <- diag(N)
Gamma3[!Gamma3] <- exp(theta.star3[1:((N-1)*N)])
Gamma3 <- Gamma3/rowSums(Gamma3)
delta3 <- solve(t(diag(N)-Gamma3+1),rep(1,N))
mu.tort3 <- exp(theta.star3[(N-1)*N+1:N])  #Mittelwert
sigma.tort3 <- exp(theta.star3[(N-1)*N+(N+1):(2*N)]) #Varianz
allprobs <- matrix(1,dim(x)[1],N)
ind <- which(!is.na(x$log.tort))
allprobs[ind,] <- cbind(dgamma(x$log.tort[ind], shape=mu.tort3[1]^2/sigma.tort3[1]^2,
scale=sigma.tort3[1]^2/mu.tort3[1]),
dgamma(x$log.tort[ind], shape=mu.tort3[2]^2/sigma.tort3[2]^2,
scale=sigma.tort3[2]^2/mu.tort3[2]),
dgamma(x$log.tort[ind], shape=mu.tort3[3]^2/sigma.tort3[3]^2,
scale=sigma.tort3[3]^2/mu.tort3[3]))
foo <- delta3%*%diag(allprobs[1,])
l <- log(sum(foo))
phi <- foo/sum(foo)
for (t in 2:dim(x)[1]){
foo <- phi%*%Gamma3%*%diag(allprobs[t,])
l <- l+log(sum(foo))
phi <- foo/sum(foo)
}
return(-l)
}
N=3
# Finding starting values
hist(data$log.tort, breaks=1000, main = "Histogram of log(tortuosity)", xlab = "log(tort)", xlim=c(0,0.1))
# Starting values
theta.star3 <- c(rep(-2,(N-1)*N),log(c(0.01,0.02,0.03)),log(c(0.005,0.01,0.02)))
# numerical maximization
mod.tort3 <- nlm(mllk.tort3,theta.star3,x=data,N=N,print.level=2,iterlim=500, stepmax = 10) # 91 iterations
theta.star3.mle <- mod.tort3$estimate
Gamma3 <- diag(N)
Gamma3[!Gamma3] <- exp(theta.star3.mle[1:((N-1)*N)])
Gamma3 <- Gamma3/rowSums(Gamma3)
delta3 <- solve(t(diag(N)-Gamma3+1),rep(1,N))
mu.tort3 <- exp(theta.star3.mle[(N-1)*N+1:N])
sigma.tort3 <- exp(theta.star3.mle[(N-1)*N+(N+1):(2*N)])
round(Gamma3, 4)
mu.tort3
sigma.tort3
delta3
hist(data$log.tort, probability = T, breaks = 500, col = "light grey", xlab = "log(tort)",
main = "State-dependent distributions", xlim = c(0,0.1))
colors <- c("#E69F00", "#009E73", "#56B4E9", "black")
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1]), add = TRUE, col = colors[1], lwd = 2, n=1001 )
curve(delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2]), add = TRUE, col = colors[2], lwd = 2, n=1001 )
curve(delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]), add = TRUE, col = colors[3], lwd = 2, n=1001 )
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1])
+ delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2])
+ delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]),
add = TRUE, col = colors[4], lwd = 2, lty = 2, n=1001)
legend("topright", inset = c(0,0), legend = c("State 1: flying", "State 2: searching/hovering",
"State 3: foraging", "Marginal distribution"),
pch = 16, col = colors)
# Starting values
theta.star3 <- c(rep(-2,(N-1)*N),log(c(0.005,0.01,0.03)),log(c(0.005,0.01,0.03)))
# numerical maximization
mod.tort3 <- nlm(mllk.tort3,theta.star3,x=data,N=N,print.level=2,iterlim=500, stepmax = 10) # 91 iterations
theta.star3.mle <- mod.tort3$estimate
Gamma3 <- diag(N)
Gamma3[!Gamma3] <- exp(theta.star3.mle[1:((N-1)*N)])
Gamma3 <- Gamma3/rowSums(Gamma3)
delta3 <- solve(t(diag(N)-Gamma3+1),rep(1,N))
mu.tort3 <- exp(theta.star3.mle[(N-1)*N+1:N])
sigma.tort3 <- exp(theta.star3.mle[(N-1)*N+(N+1):(2*N)])
round(Gamma3, 4)
mu.tort3
sigma.tort3
delta3
hist(data$log.tort, probability = T, breaks = 500, col = "light grey", xlab = "log(tort)",
main = "State-dependent distributions", xlim = c(0,0.1))
colors <- c("#E69F00", "#009E73", "#56B4E9", "black")
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1]), add = TRUE, col = colors[1], lwd = 2, n=1001 )
curve(delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2]), add = TRUE, col = colors[2], lwd = 2, n=1001 )
curve(delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]), add = TRUE, col = colors[3], lwd = 2, n=1001 )
curve(delta3[1] * dgamma(x, shape = mu.tort3[1]^2/sigma.tort3[1]^2,
scale = sigma.tort3[1]^2/mu.tort3[1])
+ delta3[2] * dgamma(x, shape = mu.tort3[2]^2/sigma.tort3[2]^2,
scale = sigma.tort3[2]^2/mu.tort3[2])
+ delta3[3] * dgamma(x, shape = mu.tort3[3]^2/sigma.tort3[3]^2,
scale = sigma.tort3[3]^2/mu.tort3[3]),
add = TRUE, col = colors[4], lwd = 2, lty = 2, n=1001)
legend("topright", inset = c(0,0), legend = c("State 1: flying", "State 2: searching/hovering",
"State 3: foraging", "Marginal distribution"),
pch = 16, col = colors)
aic <- numeric(3)
aic[1] <- 2*mod.tort3$minimum + 2*length(mod.tort3$estimate)
aic[2] <- 2*mod_slick3$minimum + 2*length(mod_slick3$estimate)
aic[3] <- 2*mod_tts3$minimum + 2*length(mod_tts3$estimate)
aic
which.min(aic)
save.image("~/Documents/Uni/Master StatWi/Seeschwalben/Environment 3.RData")
savehistory("~/Documents/Uni/Master StatWi/Seeschwalben/History 3.Rhistory")
load("~/Documents/Uni/Master StatWi/Seeschwalben/Environment 3.RData")
Gamma_slick3
round(Gamma_slick3,4)
beta_slick3 <- cbind(mod_slick3$estimate[9:14],mod_slick3$estimate[15:20])
eta3 <- beta_slick3[,1]+beta_slick3[,2]*0
Gamma_slick3 <- diag(3)
Gamma_slick3[!Gamma_slick3] <- exp(eta3) # assign values to the off-diagonal entries of the Gamma-matrix
Gamma_slick3 <- Gamma_slick3/rowSums(Gamma_slick3)
Gamma_slick3
round(Gamma_slick3,4)
eta3.1 <- beta_slick3[,1]+beta_slick3[,2]*1
Gamma_slick3.1 <- diag(3)
Gamma_slick3.1[!Gamma_slick3.1] <- exp(eta3.1) # assign values to the off-diagonal entries of the Gamma-matrix
Gamma_slick3.1 <- Gamma_slick3.1/rowSums(Gamma_slick3.1)
Gamma_slick3.1
round(Gamma_slick3.1,4)
delta3<-solve(t(diag(3)-Gamma_slick3+1),c(1,1,1))
delta3
delta3.1<-solve(t(diag(3)-Gamma_slick3.1+1),c(1,1,1))
delta3.1
aic <- numeric(3)
aic[1] <- 2*mod.tort3$minimum + 2*length(mod.tort3$estimate)
aic[2] <- 2*mod_slick3$minimum + 2*length(mod_slick3$estimate)
aic[3] <- 2*mod_tts3$minimum + 2*length(mod_tts3$estimate)
aic
which.min(aic)
bic <- numeric(3)
T <- dim(data)[1]
bic[1] <- 2*mod.tort3$minimum + log(T)*length(mod.tort3$estimate)
bic[2] <- 2*mod_slick3$minimum + log(T)*length(mod_slick3$estimate)
bic[3] <- 2*mod_tts3$minimum + log(T)*length(mod_tts3$estimate)
bic
which.min(bic)
save.image("~/Documents/Uni/Master StatWi/Seeschwalben/Environment 2 final.RData")
savehistory("~/Documents/Uni/Master StatWi/Seeschwalben/History 3 final.Rhistory")
